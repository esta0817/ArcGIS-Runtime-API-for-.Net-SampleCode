//   Copyright 2022 Esri
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

using Esri.ArcGISRuntime.Security;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Navigation;
using System.Windows.Threading;

namespace SampleCode
{

    // A helper class that manages authenticating with a server to access secure resources.
    internal static class AuthenticationHelper
    {
        // Specify the client ID and redirect URL to use for OAuth authentication.
        // Create your OAuth application metadata using the ArcGIS developer dashboard:
        // https://developers.arcgis.com/dashboard/

        private const string OAuthClientID = "2PWeGuWZHdd742iT";
        private const string OAuthRedirectUrl = "my-app://auth";

        static AuthenticationHelper()
        {
            // Use the OAuthAuthorize class (defined below) to show the login UI.
            AuthenticationManager.Current.OAuthAuthorizeHandler = new OAuthAuthorize();

            // Create a new ChallengeHandler that uses a method in this class to challenge for credentials.
            AuthenticationManager.Current.ChallengeHandler = new ChallengeHandler(PromptCredentialAsync);
        }

        // A function to register a secure server with the AuthenticationManager.
        // Pass in the URL of the server containing secure resources and, optionally, a client ID and
        // redirect URL (if not specified, the values defined above are used).
        public static void RegisterSecureServer(string url,
                                                string clientID = OAuthClientID,
                                                string redirectUrl = OAuthRedirectUrl)
        {
            // Define the server URL, authentication type, client ID, and redirect URL.
            ServerInfo portalServerInfo = new ServerInfo(new Uri(url))
            {
                TokenAuthenticationType = TokenAuthenticationType.OAuthAuthorizationCode,
                OAuthClientInfo = new OAuthClientInfo(clientID, new Uri(redirectUrl))
            };

            // Register the server information with the AuthenticationManager.
            AuthenticationManager.Current.RegisterServer(portalServerInfo);
        }

        // A function that adds a credential to AuthenticationManager based on a temporary token.
        // This is useful for testing an app with secured services without having to log in.
        public static void ApplyTemporaryToken(string url, string token)
        {
            // Create a new OAuth credential for the specified URL with the token.
            OAuthTokenCredential tempToken = new OAuthTokenCredential(new Uri(url), token);

            // Add the credential to the AuthenticationManager.
            AuthenticationManager.Current.AddCredential(tempToken);
        }

        // The ChallengeHandler function that is called when access to a secured resource is attempted.
        public static async Task<Credential> PromptCredentialAsync(CredentialRequestInfo info)
        {
            Credential credential = null;

            try
            {
                // Get credentials for the specified server. The OAuthAuthorize class (defined below)
                // will get the user's credentials (show the login window and handle the response).
                credential = await AuthenticationManager.Current.GenerateCredentialAsync(info.ServiceUri);
            }
            catch (OperationCanceledException)
            {
                // Login was cancelled, no need to display an error to the user.
            }

            return credential;
        }

        #region OAuth handler

        // In a desktop (WPF) app, an IOAuthAuthorizeHandler component is used to handle some of
        // the OAuth details. Specifically, it implements AuthorizeAsync to show the login UI
        // (generated by the server that hosts secure content) in a web control. When the user
        // logs in successfully, cancels the login, or closes the window without continuing, the
        // IOAuthAuthorizeHandler is responsible for obtaining the authorization from the server
        // or raising an OperationCanceledException.
        public class OAuthAuthorize : IOAuthAuthorizeHandler
        {
            // Window to contain the login UI provided by the server.
            private Window _authWindow;

            // Use a TaskCompletionSource to track the completion of the authorization.
            private TaskCompletionSource<IDictionary<string, string>> _tcs;

            // URL for the authorization callback result (the redirect URI configured for your application).
            private string _callbackUrl;

            // URL that handles the authorization request for the server (provides the login UI).
            private string _authorizeUrl;

            // Function to initiate an authorization request. It takes the URIs for: the secured service,
            // the authorization endpoint, and the redirect URI.
            public Task<IDictionary<string, string>> AuthorizeAsync(Uri serviceUri, Uri authorizeUri, Uri callbackUri)
            {
                // Don't start an authorization request if one is still in progress.
                if (_tcs != null && !_tcs.Task.IsCompleted)
                {
                    throw new Exception("Task in progress");
                }

                // Create a new TaskCompletionSource to track progress.
                _tcs = new TaskCompletionSource<IDictionary<string, string>>();

                // Store the authorization and redirect URLs.
                _authorizeUrl = authorizeUri.AbsoluteUri;
                _callbackUrl = callbackUri.AbsoluteUri;

                // Call a function to show the login page, make sure it runs on the UI thread for this app.
                Dispatcher dispatcher = Application.Current.Dispatcher;
                if (dispatcher == null || dispatcher.CheckAccess())
                {
                    // Currently on the UI thread, no need to dispatch.
                    ShowLoginWindow(_authorizeUrl);
                }
                else
                {
                    Action authorizeOnUIAction = () => ShowLoginWindow(_authorizeUrl);
                    dispatcher.BeginInvoke(authorizeOnUIAction);
                }

                // Return the task associated with the TaskCompletionSource.
                return _tcs.Task;
            }

            // A function to show a login page hosted at the specified Url.
            private void ShowLoginWindow(string authorizeUri)
            {
                // Create a WebBrowser control to display the authorize page.
                WebBrowser webBrowser = new WebBrowser();

                // Handle the navigation event for the browser to check for a response sent to the redirect URL.
                webBrowser.Navigating += WebBrowserOnNavigating;

                // Display the web browser in a new window.
                _authWindow = new Window
                {
                    Content = webBrowser,
                    Width = 450,
                    Height = 450,
                    WindowStartupLocation = WindowStartupLocation.CenterOwner
                };

                // Set the app's window as the owner of the browser window
                // (if main window closes, so will the browser).
                if (Application.Current != null && Application.Current.MainWindow != null)
                {
                    _authWindow.Owner = Application.Current.MainWindow;
                }

                // Handle the window closed event.
                _authWindow.Closed += OnWindowClosed;

                // Navigate the browser to the authorization url.
                webBrowser.Navigate(authorizeUri);

                // Display the window.
                _authWindow.ShowDialog();
            }

            // Handle the browser window closing.
            private void OnWindowClosed(object sender, EventArgs e)
            {
                // If the browser window closes, return the focus to the main window.
                if (_authWindow != null && _authWindow.Owner != null)
                {
                    _authWindow.Owner.Focus();
                }

                // If the task wasn't completed, the user must have closed the window without logging in.
                if (!_tcs.Task.IsCompleted)
                {
                    // Set the task completion source exception to indicate a canceled operation.
                    _tcs.SetCanceled();
                }

                _authWindow = null;
            }

            // Handle browser navigation (content changing).
            private void WebBrowserOnNavigating(object sender, NavigatingCancelEventArgs e)
            {
                // If no browser, uri, or an empty url, return.
                WebBrowser webBrowser = sender as WebBrowser;
                Uri uri = e.Uri;
                if (webBrowser == null || uri == null || string.IsNullOrEmpty(uri.AbsoluteUri))
                    return;

                // Check if browser was redirected to the callback URL (succesful authentication).
                if (uri.AbsoluteUri.StartsWith(_callbackUrl))
                {
                    e.Cancel = true;

                    // Call a function to parse key/value pairs from the response URI.
                    IDictionary<string, string> authResponse = DecodeParameters(uri);

                    // Set the result for the task completion source with the dictionary.
                    _tcs.SetResult(authResponse);

                    // Close the window.
                    if (_authWindow != null)
                    {
                        _authWindow.Close();
                    }
                }
            }

            // A function to parse key/value pairs from the provided URI.
            private static IDictionary<string, string> DecodeParameters(Uri uri)
            {
                // Get the values from the URI fragment or query string.
                string responseInfo = "";
                if (!string.IsNullOrEmpty(uri.Fragment))
                {
                    responseInfo = uri.Fragment.Substring(1);
                }
                else
                {
                    if (!string.IsNullOrEmpty(uri.Query))
                    {
                        responseInfo = uri.Query.Substring(1);
                    }
                }

                // Split the strings for each parameter (delimited with '&').
                Dictionary<string, string> keyValueDictionary = new Dictionary<string, string>();
                string[] keysAndValues = responseInfo.Split(new[] { '&' }, StringSplitOptions.RemoveEmptyEntries);

                // Iterate the parameter info and split into key/value pairs (delimited with '=').
                foreach (string kvString in keysAndValues)
                {
                    string[] pair = kvString.Split('=');
                    string key = pair[0];
                    string value = string.Empty;
                    if (key.Length > 1)
                    {
                        value = Uri.UnescapeDataString(pair[1]);
                    }
                    // Add the key and corresponding value to the dictionary.
                    keyValueDictionary.Add(key, value);
                }

                // Return the dictionary of string keys/values.
                return keyValueDictionary;
            }
        }

        #endregion OAuth handler

    }
}